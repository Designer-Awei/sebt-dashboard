<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SEBT BLE é©±åŠ¨</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }

        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .connect-button {
            display: block;
            width: 100%;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .connect-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .connect-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .status.connected {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
        }

        .status.disconnected {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #d63031;
        }

        .status.connecting {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .logs {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .logs h3 {
            margin-top: 0;
            color: #495057;
            font-size: 1.2em;
        }

        .logs-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .logs-header h3 {
            margin: 0;
            color: #495057;
            font-size: 1.2em;
        }

        .log-entry {
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.timestamp {
            color: #6c757d;
            font-size: 12px;
        }

        .log-entry.error {
            color: #dc3545;
        }

        .log-entry.success {
            color: #28a745;
        }

        .log-entry.info {
            color: #007bff;
        }

        .clear-logs {
            display: block;
            margin-top: 10px;
            padding: 8px 16px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .clear-logs:hover {
            background: #5a6268;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
            }

            .header {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”— SEBT BLE é©±åŠ¨</h1>
            <p>è¿æ¥ SEBT å¹³è¡¡æµ‹è¯•è®¾å¤‡å¹¶è½¬å‘æ•°æ®</p>
        </div>

        <div class="content">
            <button id="connectBtn" class="connect-button">
                ğŸ”— è¿æ¥ SEBT è®¾å¤‡
            </button>

            <div id="status" class="status disconnected">
                ğŸ“¡ BLE: æœªè¿æ¥
            </div>

            <div class="logs-header">
                <h3>ğŸ“ è¿æ¥æ—¥å¿—</h3>
                <button class="clear-logs" onclick="clearLogs()">æ¸…ç©ºæ—¥å¿—</button>
            </div>
            <div class="logs">
                <div id="logContainer"></div>
            </div>

        </div>
    </div>

    <script>
        // é…ç½®å¸¸é‡
        const SERVICE_UUID = '0000aaaa-0000-1000-8000-00805f9b34fb';
        const CHARACTERISTIC_UUID = '0000bbbb-0000-1000-8000-00805f9b34fb';

        // å…¨å±€å˜é‡
        let device = null;
        let characteristic = null;
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

// DOM å…ƒç´ 
const connectBtn = document.getElementById('connectBtn');
const statusDiv = document.getElementById('status');
const logContainer = document.getElementById('logContainer');

// é˜²æ­¢é‡å¤æ˜¾ç¤ºWebSocketé”™è¯¯æ—¥å¿—
let websocketErrorLogged = false;

        /**
         * æ·»åŠ è¿æ¥æ—¥å¿—ï¼ˆåªåœ¨ç”¨æˆ·æ“ä½œæ—¶æ˜¾ç¤ºï¼‰
         */
        function addConnectionLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;

            // åŒæ—¶è¾“å‡ºåˆ°æ§åˆ¶å°
            console.log(`[è¿æ¥æ—¥å¿—][${timestamp}] ${message}`);
        }

        /**
         * æ·»åŠ è°ƒè¯•æ—¥å¿—ï¼ˆåªè¾“å‡ºåˆ°æ§åˆ¶å°ï¼Œä¸æ˜¾ç¤ºåœ¨ç•Œé¢ï¼‰
         */
        function addDebugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            console.log(`[${timestamp}] ${message}`);
        }

        /**
         * æ›´æ–°çŠ¶æ€æ˜¾ç¤º
         */
        function updateStatus(message, className) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${className}`;
            addConnectionLog(message, className === 'connected' ? 'success' : className === 'disconnected' ? 'error' : 'info');
        }

/**
 * æ¸…ç©ºæ—¥å¿—
 */
function clearLogs() {
    logContainer.innerHTML = '';
    addLog('æ—¥å¿—å·²æ¸…ç©º', 'info');
}



        /**
         * è¿æ¥ WebSocket
         */
        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                return;
            }

            addDebugLog('æ­£åœ¨è¿æ¥ WebSocket...', 'info');
            ws = new WebSocket('ws://localhost:3000/ws');

            ws.onopen = () => {
                addDebugLog('WebSocket è¿æ¥æˆåŠŸ', 'success');
                reconnectAttempts = 0;
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);

                    // å¤„ç†æ¥è‡ªElectronçš„æ•°æ®
                    if (data.type === 'connected') {
                        addDebugLog(`æ”¶åˆ°æœåŠ¡å™¨æ¶ˆæ¯: ${data.message}`, 'success');
                    } else if (data.type === 'host_sensor_data' || data.type === 'sensor_data') {
                        // æ•°æ®å·²é€šè¿‡BLEç›´æ¥ä¼ é€’ï¼Œä¸éœ€è¦é¢å¤–æ˜¾ç¤º
                        addDebugLog(`æ”¶åˆ°ä¼ æ„Ÿå™¨æ•°æ®: æ–¹å‘=${data.minDirection}, è·ç¦»=${data.minDistance}mm`, 'info');
                    } else if (data.type === 'host_connected') {
                        addConnectionLog('ä¸»æœºBLEè®¾å¤‡å·²è¿æ¥', 'success');
                    } else if (data.type === 'host_disconnected') {
                        addConnectionLog('ä¸»æœºBLEè®¾å¤‡å·²æ–­å¼€', 'error');
                    } else if (data.type === 'close_ble_driver') {
                        addDebugLog(`æ”¶åˆ°å…³é—­æŒ‡ä»¤: ${data.message}`, 'info');
                        // Electronä¸»çª—å£å·²å…³é—­ï¼Œè‡ªåŠ¨å…³é—­BLEé©±åŠ¨é¡µé¢
                        addConnectionLog('Electronä¸»çª—å£å·²å…³é—­ï¼Œæ­£åœ¨å…³é—­BLEé©±åŠ¨é¡µé¢...', 'info');
                        setTimeout(() => {
                            window.close();
                        }, 2000); // 2ç§’åè‡ªåŠ¨å…³é—­ï¼Œç»™ç”¨æˆ·æ—¶é—´çœ‹åˆ°æ¶ˆæ¯
                    } else {
                        addDebugLog(`æ”¶åˆ°æœåŠ¡å™¨æ¶ˆæ¯: ${data.type}`, 'info');
                    }
                } catch (error) {
                    addDebugLog(`è§£ææœåŠ¡å™¨æ¶ˆæ¯å¤±è´¥: ${error.message}`, 'error');
                }
            };

            ws.onclose = () => {
                addDebugLog('WebSocket è¿æ¥æ–­å¼€', 'error');
                // è‡ªåŠ¨é‡è¿
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    setTimeout(() => {
                        addDebugLog(`å°è¯•é‡è¿ WebSocket (${reconnectAttempts}/${maxReconnectAttempts})`, 'info');
                        connectWebSocket();
                    }, 2000 * reconnectAttempts);
                }
            };

            ws.onerror = (error) => {
                addDebugLog(`WebSocket é”™è¯¯: ${error}`, 'error');
            };
        }

        /**
         * å‘é€æ•°æ®åˆ° Electron
         */
        function sendToElectron(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
                addDebugLog(`å‘é€æ•°æ®åˆ° Electron: ${data.type}`, 'info');
                // é‡ç½®é”™è¯¯æ ‡å¿—ï¼Œè¯´æ˜è¿æ¥å·²æ¢å¤
                websocketErrorLogged = false;
            } else {
                // åªåœ¨ç¬¬ä¸€æ¬¡é‡åˆ°é”™è¯¯æ—¶æ˜¾ç¤ºæ—¥å¿—
                if (!websocketErrorLogged) {
                    addConnectionLog('WebSocket æœªè¿æ¥ï¼Œæ— æ³•å‘é€æ•°æ®', 'error');
                    websocketErrorLogged = true;
                }
            }
        }

        /**
         * è¿æ¥ BLE è®¾å¤‡
         */
        async function connectBLEDevice() {
            try {
                addConnectionLog('ğŸ”„ BLE: æ­£åœ¨è¯·æ±‚è®¾å¤‡æƒé™...', 'info');
                updateStatus('ğŸ”„ BLE: æ­£åœ¨è¯·æ±‚è®¾å¤‡æƒé™...', 'connecting');
                connectBtn.disabled = true;

                // è¯·æ±‚ BLE è®¾å¤‡
                device = await navigator.bluetooth.requestDevice({
                    filters: [{ services: [SERVICE_UUID] }],
                    optionalServices: ['battery_service', 'device_information']
                });

                addConnectionLog(`å‘ç°è®¾å¤‡: ${device.name || 'æœªçŸ¥è®¾å¤‡'}`, 'success');

                updateStatus('ğŸ”„ BLE: æ­£åœ¨è¿æ¥ GATT æœåŠ¡å™¨...', 'connecting');

                // è¿æ¥ GATT æœåŠ¡å™¨
                const server = await device.gatt.connect();
                addConnectionLog('GATT æœåŠ¡å™¨è¿æ¥æˆåŠŸ', 'success');

                updateStatus('ğŸ”„ BLE: æ­£åœ¨å‘ç°æœåŠ¡...', 'connecting');

                // è·å–æœåŠ¡
                const service = await server.getPrimaryService(SERVICE_UUID);
                addConnectionLog('æœåŠ¡å‘ç°æˆåŠŸ', 'success');

                updateStatus('ğŸ”„ BLE: æ­£åœ¨å‘ç°ç‰¹å¾...', 'connecting');

                // è·å–ç‰¹å¾
                characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);
                addConnectionLog('ç‰¹å¾å‘ç°æˆåŠŸ', 'success');

                updateStatus('ğŸ”„ BLE: æ­£åœ¨å¯ç”¨é€šçŸ¥...', 'connecting');

                // å¯ç”¨é€šçŸ¥
                await characteristic.startNotifications();
                addConnectionLog('é€šçŸ¥å·²å¯ç”¨', 'success');

                updateStatus('âœ… BLE: å·²è¿æ¥', 'connected');
                connectBtn.textContent = 'ğŸ”Œ æ–­å¼€è¿æ¥';
                connectBtn.disabled = false;

                // è®¾ç½®æ•°æ®æ¥æ”¶å¤„ç†
                characteristic.addEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);

                // è®¾å¤‡æ–­å¼€å¤„ç†
                device.addEventListener('gattserverdisconnected', handleDisconnection);

            } catch (error) {
                addConnectionLog(`BLE è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                updateStatus('âŒ BLE: è¿æ¥å¤±è´¥', 'disconnected');
                connectBtn.disabled = false;
                connectBtn.textContent = 'ğŸ”— è¿æ¥ SEBT è®¾å¤‡';
            }
        }

        /**
         * å¤„ç†ç‰¹å¾å€¼å˜åŒ–
         */
        function handleCharacteristicValueChanged(event) {
            try {
                const value = event.target.value;
                const data = new DataView(value.buffer);

                // è§£ææ•°æ®æ ¼å¼: [æ—¶é—´æˆ³(4å­—èŠ‚)] [æœ€å°æ–¹å‘(1å­—èŠ‚)] [æœ€å°è·ç¦»(2å­—èŠ‚)] [8æ–¹å‘è·ç¦»(16å­—èŠ‚)]
                const timestamp = data.getUint32(0, true);
                const minDirectionRaw = data.getUint8(4);
                const minDirection = minDirectionRaw === 255 ? -1 : minDirectionRaw;
                const minDistance = data.getUint16(5, true);

                const distances = [];
                for (let i = 0; i < 8; i++) {
                    distances.push(data.getUint16(7 + i * 2, true));
                }

                // æ„å»ºæ•°æ®å¯¹è±¡
                const sensorData = {
                    type: 'sensor_data',
                    timestamp: timestamp,
                    minDirection: minDirection,
                    minDistance: minDistance,
                    distances: distances,
                    source: 'host',
                    name: device.name || 'SEBT-Host',
                    address: device.id
                };

                // å‘é€åˆ° Electron
                sendToElectron(sensorData);

                addDebugLog(`æ”¶åˆ°ä¼ æ„Ÿå™¨æ•°æ®: æ–¹å‘=${minDirection}, è·ç¦»=${minDistance}mm`, 'info');

            } catch (error) {
                addConnectionLog(`è§£æä¼ æ„Ÿå™¨æ•°æ®å¤±è´¥: ${error.message}`, 'error');
            }
        }

        /**
         * å¤„ç†è®¾å¤‡æ–­å¼€
         */
        function handleDisconnection() {
            addConnectionLog('BLE è®¾å¤‡å·²æ–­å¼€è¿æ¥', 'error');
            updateStatus('âŒ BLE: å·²æ–­å¼€', 'disconnected');
            connectBtn.textContent = 'ğŸ”— è¿æ¥ SEBT è®¾å¤‡';
            connectBtn.disabled = false;

            device = null;
            characteristic = null;
        }

        /**
         * æ–­å¼€ BLE è¿æ¥
         */
        async function disconnectBLEDevice() {
            try {
                addConnectionLog('æ­£åœ¨æ–­å¼€BLEè¿æ¥...', 'info');
                if (characteristic) {
                    await characteristic.stopNotifications();
                }
                if (device && device.gatt.connected) {
                    device.gatt.disconnect();
                }
                addConnectionLog('BLEè¿æ¥å·²æ–­å¼€', 'info');
                handleDisconnection();
            } catch (error) {
                addConnectionLog(`æ–­å¼€è¿æ¥æ—¶å‡ºé”™: ${error.message}`, 'error');
            }
        }

        /**
         * æŒ‰é’®ç‚¹å‡»å¤„ç†
         */
        connectBtn.addEventListener('click', async () => {
            if (device && device.gatt.connected) {
                await disconnectBLEDevice();
            } else {
                await connectBLEDevice();
            }
        });

        /**
         * é¡µé¢åŠ è½½æ—¶çš„åˆå§‹åŒ–
         */
        window.addEventListener('load', () => {
            addDebugLog('BLE é©±åŠ¨é¡µé¢å·²åŠ è½½', 'info');

            // æ£€æŸ¥ Web Bluetooth æ”¯æŒ
            if (!navigator.bluetooth) {
                addConnectionLog('æµè§ˆå™¨ä¸æ”¯æŒ Web Bluetooth API', 'error');
                updateStatus('âŒ BLE: æµè§ˆå™¨ä¸æ”¯æŒ', 'disconnected');
                connectBtn.disabled = true;
                return;
            }

            addDebugLog('Web Bluetooth API æ”¯æŒæ£€æµ‹é€šè¿‡', 'success');

            // è¿æ¥ WebSocket
            connectWebSocket();
        });

        /**
         * é¡µé¢å¸è½½æ—¶çš„æ¸…ç†
         */
        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.close();
            }
            if (device && device.gatt.connected) {
                device.gatt.disconnect();
            }
        });
    </script>
</body>
</html>
